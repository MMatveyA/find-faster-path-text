\documentclass[12pt,chapterprefix=true,headings=onelineappendix]{scrartcl}
\KOMAoptions{toc=sectionentrydotfill}

\usepackage{fontspec}
\setmainfont{Liberation Serif}
\setsansfont{Liberation Sans}
% \setmonofont{Liberation Mono}
\usepackage[main=russian,english]{babel}

\usepackage[a4paper,top=20mm,bottom=30mm,left=20mm,right=20mm]{geometry}

\usepackage[backend=biber,style=gost-numeric,sorting=nty]{biblatex}
\usepackage{csquotes}
\addbibresource{external.bib}

\usepackage[ddmmyyyy]{datetime}
\renewcommand{\dateseparator}{.}

\usepackage{graphicx}
\graphicspath{{./images/}}

\usepackage{amsfonts, amssymb, amsmath, microtype, multirow}

\usepackage{tabularx}
\newcolumntype{L}{>{\raggedleft\arraybackslash}X}
\newcolumntype{C}{>{\centering\arraybackslash}X}
\usepackage{booktabs}
\usepackage{multirow}

\usepackage[ruled,vlined]{algorithm2e}
\renewcommand{\algorithmcfname}{Алгоритм}
\IncMargin{1em}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  filecolor=black,
  urlcolor=black,
  pdftitle={Нахождение быстрейшего пути},
  pdfauthor={Максимов Матвей (C23-201-1)},
}

\usepackage{pdfpages}

\usepackage{listing}
\usepackage{caption}
\captionsetup[listing]{name=Листинг}
\usepackage{minted}
\setminted{
  frame=lines,
  framesep=2mm,
  baselinestretch=1.2,
  fontsize=\scriptsize,
  linenos
}

\renewcommand{\listingname}{Листинг}

\RedeclareSectionCommand[
  beforeskip=2\baselineskip,
  afterindent=false,
  afterskip=.5\baselineskip,
  tocentrynumberformat=\def\autodot{.}
   ]{section}

\begin{document}
\begin{titlepage}

	\begin{center}
		\uppercase{минобрнауки россии} \\
		Федеральное государственное бюджетное образовательное
		учреждение высшего образования \\
		<<Ижевский государственный технический университет имени М.~Т.~Калашникова>> \\
		Факультет <<Приборостроительный>>\\
		Кафедра <<Радиотехника>>\\
	\end{center}

	\vfill

	\begin{flushright}
		\begin{tabularx}{0.4\textwidth}{X}
			Работа защищена с оценкой \\
			<<\hrulefill{}>>          \\
			Дата \hrulefill{}         \\
			Подпись \hrulefill{}/\hrulefill{}\hrulefill{}
		\end{tabularx}
	\end{flushright}

	\vfill

	\begin{center}
		\textbf{Курсовая работа} \\
		по дисциплине <<Современные языки программирования>> \\
		Тема <<Разработка программы для логической задачи на языке программирования C++>> \\
	\end{center}

	\vfill

	\begin{center}
		\begin{tabularx}{0.95\textwidth}{X p{5.1cm} r}
			Выполнил                                &                                                                                        &                \\
			Студент гр. С23-201-1                   & $\underset{\text{дата, подпись}}{\underline{\text{\today{}}\hspace{0.195\textwidth}}}$ & Максимов М. А. \\
			Проверил                                &                                                                                        &                \\
			к.п.н., доцент кафедры <<Радиотехника>> & $\underset{\text{дата, подпись}}{\underline{\hspace{0.3\textwidth}}}$                  &                \\
		\end{tabularx}
	\end{center}

	\vfill
	\begin{flushleft}
		Рецензия:  \\
		степень достижения поставленной цели работы \hrulefill{} \\
		полнота разработки темы \hrulefill{ } \\
		уровень самостоятельности работы обучающегося \hrulefill{} \\
		недостатки работы \hrulefill{}\\
	\end{flushleft}

\end{titlepage}

\tableofcontents

\newpage{}
\section*{Введение}
\addcontentsline{toc}{section}{Введение}

\emph{Целью} курсовой работы является закрепление и демонстрация знаний,
полученных при изучении дисциплины <<Современные языки программирования>>. В
данной работе необходимо поставить конкретные задачи по заданной теме, которые
будут определять весь ход выполнения курсовой работы.

\emph{Актуальность данной темы} (разработка программы для нахождения
кратчайшего пути между двумя точками) связана с тем, что поиск и построение
наиболее оптимального пути между двумя точками имеет широкое применение в
различных областях~\cite{Sokolov-graph_in_logistic,
	Vardomatskaya-optimization_with_graphs, Брюске1998-графыАлгоритмов}:
\begin{itemize}
	\item \textbf{Навигация и картография}: поиск оптимальных маршрутов для
	      автомобилей, пешеходов, общественного транспорта, беспилотных транспортных
	      средств.
	\item \textbf{Логистика и доставка}: Оптимизация маршрутов доставки товаров,
	      планирование перевозок, минимизация затрат на топливо и время.
	\item \textbf{Робототехника}: Планирование движения роботов в среде с
	      препятствиями, поиск оптимальных траекторий для выполнения задачи.
	\item \textbf{Игры}: Создание реалистичных систем навигации для персонажей в
	      видеоиграх, расчёт кратчайших путей для противников или NPC.
\end{itemize}

Выполнение курсовой работы требует творческого подхода и всестороннего
исследования поставленных задач.

Основными задачами курсовой работы является:
\begin{itemize}
	\item Применение знаний и умений работать с языком программирования к
	      конкретно поставленному заданию.
	\item Разработка словесного алгоритма программы для обучения нахождению
	      кратчайшего пути между точками в соответствии с поставленными условиями.
	\item Реализация данного алгоритма на языке программирования C++, то есть
	      непосредственная разработка алгоритма в программе C++ с помощью её
	      синтаксиса.
\end{itemize}

Основный этапы курсовой работы являются:
\begin{enumerate}
	\item Анализ поставленной задачи.
	\item Выбор обоснования и изложения метода решения поставленной задачи.
	\item Построение алгоритма решения поставленной задачи.
	\item Создание и отладка программы.
	\item Разработка комплекта тестов для проверки правильности работы программы.
	\item Оформление пояснительной записки.
	\item Защита курсовой работы.
\end{enumerate}

Таким образом в процессе выполнения работы необходимо научиться работать с
литературой и интернет--ресурсами, список которых включён в конец курсовой
работы.

% Main section

\newpage{}
\section{Постановка задач}
Выполнение задания следует начинать с чёткого уяснения поставленной задачи.
Задача курсовой работы звучит следующим образом: найти кратчайший путь между
двумя точками, расположенными на двух произвольных клетках на поле 10x10, при
условии, что движение возможно только по вертикали, горизонтали и диагонали. То
есть в начале задаётся две некоторые координаты, в которых располагаются старт
и финиш, и надо построить кратчайший путь между ними.

Так как задача слишком проста, было решено добавить дополнительные условия к
уже имеющимся:
\begin{itemize}
	\item Возможность выбрать любой размер поля;
	\item Возможность расставлять препятствия на поле;
\end{itemize}

Данная задача относится к обучающим задачам, так как, чтобы найти кратчайший
путь между двумя точками, необходимо обучиться алгоритму решения такой задачи.
Метод решения данной задачи должен описывать, каким образом получается исходный
результат.

Существует несколько методов решения такой задачи. Необходимо выбрать
наиболее оптимальный. Критерии выбора метода решения данной задачи, на
которые следует опираться, следующие:
\begin{enumerate}
	\item Легкость реализации в виде алгоритма;
	\item Время решения задачи;
	\item Возможность проверки правильности решения.
\end{enumerate}

\newpage{}
\section{Математические методы и средства решения задач}

\textbf{Метод решения поставленной задачи} обязательно должен опираться на
некоторый математический аппарат. В качестве основного алгоритма был выбран A-star.
Краткое изложение принципа работы алгоритма:

\begin{displayquote}
	В начале работы просматриваются узлы, смежные с начальным; выбирается тот из
	них, который имеет минимальное значение $f(x)$ (стоимость клетки), после чего
	этот узел раскрывается. На каждом этапе алгоритм оперирует с множеством путей
	из начальной точки до всех ещё не раскрытых (листовых) вершин графа —
	множеством частных решений, — которое размещается в очереди с приоритетом.
	Приоритет пути определяется по значению $f(x) = g(x) + h(x)$, где $g(x)$ ---
	стоимость передвижения из стартовой точки A к данной клетке, следуя
	найденному пути к этой клетке, $h(x)$ --- примерная стоимость передвижения от
	данной клетки до целевой. Алгоритм продолжает свою работу до тех пор, пока
	значение $f(x)$ целевой вершины не окажется меньшим, чем любое значение в
	очереди, либо пока всё дерево не будет просмотрено. Из множества решений
	выбирается решение с наименьшей стоимостью~\cite{ЖанЛуи1991,Рассел2006}.
\end{displayquote}

Этот алгоритм был выбран, так как он оптимально эффективен для заданной
эвристики $h$. Это означает, что любой другой алгоритм исследует не меньше
узлов, чем A-star (за исключением случаев, когда существует несколько частных
решений с одинаковой эвристикой, точно соответствующей стоимости оптимального
пути)~\cite{Wikipedia:A-star}.

Если эвристическая функция h допустима, то есть никогда не переоценивает
действительную ми\-ни\-маль\-ную стоимость достижения цели, то A-star сам является
допустимым (или оптимальным), также при условии, что мы не отсекаем пройденные
вершины. Если же мы это делаем, то для оптимальности алгоритма требуется, чтобы
$h(x)$ была ещё и монотонной, или преемственной эвристикой. Свойство монотонности
означает, что если существуют пути A—B—C и A—C (необязательно через B), то
оценка стоимости пути от A до C должна быть меньше либо равна сумме оценок
путей A—B и B—C. (Монотонность также известна как неравенство треугольника:
одна сторона треугольника не может быть длиннее, чем сумма двух других сторон.)
Математически, для всех путей x, y (где y — потомок x) выполняется:

\[ g(x) + h(x) \leq g(y) + h(y) \]

Для решения задачи было принято решение написать программу на языке
программирования C++. Такое решение было принято исходя из целого ряда
преимуществ языка:

\begin{itemize}
	\item C++ --- это строгий типизированный язык, что позволяет проверить на
	      правильность большую часть кода ещё до запуска программы;
	\item Для этого языка уже было написано множество различных библиотек,
	      упрощающих написание кода;
	\item Язык практически не имеет overhead\footnote{В информатике накладные
		      расходы (overhead) --- это любое сочетание избыточного или косвенного
		      времени вычислений, памяти, пропускной способности или других ресурсов,
		      которые необходимы для выполнения конкретной
		      задачи~\cite{NVIDIACorporation2020}}, что позволяет писать маленькие и
	      быстрые программы.
\end{itemize}

\newpage{}
\section{Описание данных}

\begin{table}[htpb]
	\centering
	\begin{tabularx}{\textwidth}[htpb]{l C r}
		\toprule
		Название в задаче & Тип                         & Смысловое понятие                   \\
		\toprule
		\multicolumn{3}{c}{Входные данные}                                                    \\
		\midrule
		\verb|start|      & \verb|Vector2|              & Координаты первой точки             \\
		\verb|goal|       & \verb|Vector2|              & Координаты второй точки             \\
		\bottomrule
		\multicolumn{3}{c}{Выходные данные}                                                   \\
		\midrule
		\verb|result|     & \verb|std::vector<Vector2>| & Массив координат получившегося пути \\
		\bottomrule
	\end{tabularx}
	\caption{Описание данных}
	\label{tab:description-data}
\end{table}

\newpage{}
\section{Алгоритм задачи}

A-star пошагово просматривает все пути, ведущие от начальной вершины в конечную,
пока не найдёт минимальный. Как и все информированные алгоритмы
поиска\footnote{Информированный поиск --- стратегия поиска решений в
	пространстве состояний, в которой используются знания, относящиеся к
	конкретной задаче. Информированные методы обычно обеспечивают более
	эффективный поиск по сравнению с неинформированными методами}, он просматривает
сначала те маршруты, которые <<кажутся>> ведущими к цели. От жадного
алгоритма\footnote{Жадный алгоритм --- алгоритм, заключающийся в принятии
	локально оптимальных решений на каждом этапе, допуская, что конечное решение
	также окажется оптимальным. Известно, что если структура задачи задается
	матроидом, тогда применение жадного алгоритма выдаст глобальный оптимум},
который тоже является алгоритмом поиска по первому лучшему совпадению, его
отличает то, что при выборе вершины он учитывает, помимо прочего, весь
пройденный до неё путь. Составляющая $g(x)$ --- это стоимость пути от начальной
вершины, а не от предыдущей, как в жадном алгоритме.

В начале работы просматриваются узлы, смежные с начальным; выбирается тот из
них, который имеет минимальное значение $f(x)$, после чего этот узел
раскрывается. На каждом этапе алгоритм оперирует с множеством путей из
начальной точки до всех ещё не раскрытых (листовых) вершин графа — множеством
частных решений, — которое размещается в очереди с приоритетом\footnote{Очередь
	с приоритетом --- абстрактный тип данных в программировании, поддерживающий
	две обязательные операции — добавить элемент и извлечь
	максимум\cite{Sedgewick2011} (минимум). Предполагается, что для каждого
	элемента можно вычислить его приоритет — действительное число или в общем
	случае элемент линейно упорядоченного множества\cite{Ахо2001}}. Приоритет пути
определяется по значению $f(x) = g(x) + h(x)$. Алгоритм продолжает свою работу
до тех пор, пока значение $f(x)$ целевой вершины не окажется меньшим, чем любое
значение в очереди, либо пока всё дерево не будет просмотрено. Из множества
решений выбирается решение с наименьшей стоимостью.

Чем меньше эвристика $h(x)$, тем больше приоритет, поэтому для реализации
очереди можно ис\-поль\-зо\-вать сортирующие деревья\footnote{Двоичная куча,
	пирамида\cite{Кормен2005}, или сортирующее дерево --- такое двоичное дерево,
	для которого выполнены три условия:

	\begin{enumerate}
		\item Значение в любой вершине не меньше, чем значения её потомков.
		\item Глубина всех листьев (расстояние до корня) различается не более чем
		      на 1 слой.
		\item Последний слой заполняется слева направо без <<дырок>>
	\end{enumerate}
}.

\begin{algorithm}
	\caption{Псевдокод алгоритма A-star}
	\LinesNumbered{}

	\SetKwComment{Comment}{/* }{ */}
	\SetKwData{Left}{left}
	\SetKwData{This}{this}
	\SetKwData{Up}{up}
	\SetKwFunction{add}{add}
	\SetKwFunction{enqueue}{enqueue}
	\SetKwFunction{makeQueue}{make\_queue}
	\SetKwFunction{set}{set}
	\SetKwFunction{successors}{successors}
	\SetKwInOut{Input}{input}
	\SetKwInOut{Output}{output}

	\Input{
		start --- начало пути;
		goal --- конец пути;
		f --- эвристическая функция
	}
	\Output{
		массив точек оптимального пути
	}
	\BlankLine

	closed \gets \set{} \tcc*{множество уже пройденных точек}
	open \gets \makeQueue{f} \tcc*{множество частных решений}
	\enqueue{open, path(start)}\;
	\While{open \neq \set()}{
		p \gets remove\_first(open)\;
		x \gets \emph{the last node of p}\;
		\If{x in closed}{
			continue\;
		}
		\If{x = goal}{
			return p\;
		}
		\add{closed, x}\;
		\tcc{добавляем смежные вершины}
		\ForEach{y in \successors{x}}{
			\enqueue{open, add\_to\_path(p, y)}\;
		}
	}
	return failure\;
\end{algorithm}

\newpage{}
\section{Программа на языке программирования C++}

Программа написана на языке программирования С++ с использованием
элементов меню и библиотекой ncurses\cite{ПроектGNU1993-ncurses}. Для
компиляции использовались: cmake\cite{Kitware2000-cmake}, make,
llvm~\cite{LLVMFoundation2024}, nix~\cite{Долстра2003}.

Для компиляции проекта используется \verb|cmake|. Основной файл
\verb|CMakeLists.txt| представлен на листинге~\ref{build:cmake}. Строки с 1 по
6 устанавливают вспомогательные данные. 8 строка добавляет новую опцию
\verb|BUILD_DOC|. При её активации \verb|cmake| также создаст \verb|*.tex|
файлы для документации. 10 строка подключает к сборке все файлы с расширением
\verb|.cpp| из директории \verb|src|. Строки с 12 по 16 подключают необходимые
библиотеки. Строки с 18 по 20 добавляют к сборке субдиректорию \verb|docs|,
если включена опция \verb|BUILD_DOC|. Последние две строки добавляют выбранные
файлы к компиляции и включают линковку\footnote{Компоновщик ---
	инструментальная программа, которая производит компоновку (<<линковку>>):
	принимает на вход один или несколько объектных модулей и собирает из них
	исполняемый или библиотечный файл--модуль} нужных библиотек.

\begin{listing}[H]
	\inputminted[
		frame=lines,
		linenos,
		framesep=2mm,
		fontsize=\footnotesize,
	]{cmake}{./code/CMakeLists.txt}
	\caption{CMakeLists.txt}\label{build:cmake}
\end{listing}

Для воспроизводимости сборки, а также автоматической передачи необходимых опций
используется пакетный менеджер \verb|nix|. Для работы его подкоманды \verb|nix build|
используется файл \verb|default.nix| (листинг~\ref{build:nix}). На строке 8
задаются зависимости, необходимые для сборки проекта. Далее на строке 9
задаются зависимости, необходимые для сборки проекта и последующего запуска
бинарных файлов. На 11 строке задаются передаваемые опции сборки. Далее с 13 по
21 строку указываются команды для установки программы, а именно компиляция
документации и перемещение нужных файлов в выходной каталог. Остальные строки
вспомогательные и не обязательны для успешной компиляции.

\begin{listing}[H]
	\inputminted[
		frame=lines,
		linenos,
		framesep=2mm,
		fontsize=\footnotesize,
	]{nix}{./code/default.nix}
	\caption{default.nix}\label{build:nix}
\end{listing}

\newpage{}
\section{Тестовый пример}

\newpage{}
\section{Руководство пользователя для работы с программой}
\newpage{}

\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}

\newpage
\nocite{*}
\printbibliography[heading=bibintoc]

\end{document}
